#!/usr/bin/env ruby
# frozen_string_literal: true

require "optimist"
require "floe"
require "floe/container_runner"

opts = Optimist.options do
  version("v#{Floe::VERSION}\n")
  usage("[options] workflow input [workflow2 input2]")

  opt :workflow, "Path to your workflow json (legacy)",         :type => :string
  opt :input, "JSON payload to input to the workflow (legacy)", :type => :string
  opt :context, "JSON payload of the Context",                  :type => :string
  opt :credentials, "JSON payload with credentials",            :type => :string
  opt :credentials_file, "Path to a file with credentials",     :type => :string

  Floe::ContainerRunner.cli_options(self)

  banner("")
  banner("General options:")
end

# legacy support for --workflow
args = ARGV.empty? ? [opts[:workflow], opts[:input]] : ARGV
Optimist.die(:workflow, "must be specified") if args.empty?

Floe::ContainerRunner.resolve_cli_options!(opts)

require "logger"
Floe.logger = Logger.new($stdout)

credentials =
  if opts[:credentials_given]
    opts[:credentials] == "-" ? $stdin.read : opts[:credentials]
  elsif opts[:credentials_file_given]
    File.read(opts[:credentials_file])
  end

workflows =
  args.each_slice(2).map do |workflow, input|
    context = Floe::Workflow::Context.new(opts[:context], :input => input || opts[:input] || "{}")
    Floe::Workflow.load(workflow, context, credentials)
  end

# run

Floe::Workflow.wait(workflows, &:run_nonblock)

# display status

workflows.each do |workflow|
  puts "", "#{workflow.name}#{" (#{workflow.status})" unless workflow.context.success?}", "===" if workflows.size > 1
  puts workflow.output.inspect
end

# exit status

exit workflows.all? { |workflow| workflow.context.success? } ? 0 : 1
